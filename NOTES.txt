PERL PERL PERL NOTEPAD 




==========Numerical values / Numerieke waarden===== https://perlmaven.com/numerical-operators

say 2 + 3;   # 5
say 2 * 3;   # 6
say 9 - 5;   # 4
say 8 / 2;   # 4
 
say 8 / 3;   # 2.66666666666667
# Note that Perl will automatically switch to floating point number when necessary so when we divide 8 by 3 we get a floating point value.
say 9 % 2;   # 1
say 9 % 5;   # 4
 
my $x = 2;
my $y = 3;
 
say $x + $y;  # 5
say $x / $y;  # 0.666666666666667

-------Shorthand operators---
The expression $x += 3; is the shorthand version of $x = $x + 3;, they have exactly the same result:
my $x = 2;
say $x; # 2
 
$x = $x + 3;
say $x; # 5
 
my $y = 2;
say $y;  # 2
$y += 3;
say $y;  # 5

#In the general case VARIABLE OP= EXPRESSION is the same as VARIABLE = VARIABLE OP EXPRESSION, but usually easier to read and less error-prone.
#(We don't repeat the name of VARIABLE.) You can use it with any binary operator:
#+=, *=, -=, /=, even %=

-----Auto increment and auto decrement----
#Perl also provides ++ the auto increment, and -- auto decrement operators.
#They increase and decrease respectively the value of a scalar variable by 1.

my $x = 2;
say $x; # 2
$x++;
say $x; # 3
 
$x--;
say $x; # 2

#Both the postfix versions $x++, $x-- and the prefix versions ++$x, --$x and they behave the same way as in other languages.
#In case you are not familiar with them, then this is not the time to become deeply acquainted with them.

#They can be used as part of a larger expression when being pre-fix or post-fix really matters, but in most cases I think the best is to avoid such expressions.
#They can be fun and a maintenance nightmare. We'll have an article explaining short-circuit and the pitfalls of auto increment with short-circuit.



----Communicatieve bewerkingen-----
| 
|
bv: 2 + 3*4 = 14 : correct mathematische volgorde ( eerst *)
Geforceerde mathematische volgorde
bv: (2+3)*4 = 20

Comparison Operators
< <= == >= > !=

Comparison - Numeric - String
equal  ==       eq
Not equal != ne
Less than < =lt
Greater Than > = gt
Less than or equal to <= le
Greater than or equal to >= ge

user input 
$line = <STDIN>; 
if ($line eq "\n") {
   print "That was just a blank line!\n";
  } else { 
   print "That line of input was: $line";
  }

???---------------------------------
undef P40

./Build && ./Build install && dhconveyor transport -p testit.ini -L 3
------------------------------------------------------------------------------------------
ListEn Arrays

Meerder waarden in variabele: 
List and arrays

List = Data & Array = Variabele 
You can have a list variable that isn't an array but every array variable holds a list (although that list may be empty)

Your next step could be to write a program, and then wehn you get stuck, post a question in SoPW. See SSCCE. (1) This is what I tried; (2) This is is what it produces; (3) This is what I want to happen; (4) Help please?

use 5.18.0 = Use version of perl always in strict mode = "use strict;"

$x =  $x + 100; same thing as $x += 100;;
Whiespace and comments

Whitespace = space characters, tab characters,  - mostly ignored. 
except ex. "sub main" ! "submain" needs white spae

{ } around var = clearly var even without whitespace
Comment to make src code more readable

sub main
{                   #accolades better idea of placement because more clear  
 my $filename = shift || "linesfile.txt";
 my $count = countlines ( $filename );
}

blocks are  defined by { } 

vars inside block override variable outside block. 
vars outside block cannot reach var declaration inside block. par ex.

my $x = 1;                                                            my $x = 1;                       
if ($x) {                                                                  if ($x) {
    my $y = 2;                            not                          my $y = 2;      
    say $y;                                                               }
}                                                                                  say $y

output: Global symbol "$y" requires explicit package name...................

Variable is symply a names container for values. 
var name can be any set of characters 

3 Perl storage types:
scalar, holds a single value
SCALAR variable= SCALAR with $ 
ARRAY holds series of values = @array = extracting the value will output same order of entered values 
%HASH, holds a set of key/value pairs.

Perl references,
A SCALAR that refers to another object
$x = <STDIN>;
print $x;

Numeric Variables:
Assign number to var, 
my $n = 42;
$n = $n * 2;
print "n is $n"; 
output will be:
n is 84

[ ] around print variable will show where the var starts in output (shows where the boundries of the string are)
par ex. 
"print "n is [$n]";


String Value in Perl:
par ex. 
my $s = "Hello world";
print "s is [$s]";

my $s = "Hello world";
$s = $s . " This is a string. "; ##### concatonation operator "." added one string on top of another.
print "s is [$s]";

string interpolation  when you have a var inside of the string and that var is expanded inside of the string. 

my $s = "Hello world";
$s = "This is a string. $s this is another string.";
print "s is [ $s]";

To expand variable. 

my $s = "Hello world";
$s = "This is a string. ${s} this is another string.";
print "s is [ $s]";

escaping
if you want quote marks use = \"content"\ display " as quote marks not as syntax
\\ = \ single backslash

qq( content ) = interpolation quote operator -  

-------------------------------------------------------------------- 
_______________________Logical values_______________________________

Are used in conditionals and loops
my $x = 1;
my $y = 1;

if (  $x == $y ) {
   say 'true';
} else { 
     say 'false';
}

if statement takes a logical value to decide which block of code will be executed 
== : tests for equality 

Lists and Arrays
List,  a fixed series of scalar values

print foreach (1, 2, 3);
out will be: 
1
2
3

qw = quote word operator, create list of strings.
par ex.
print qw( one two three )[1]

@array, is a variable data structure that holds a series of scalar values.

my @array = (1, 2, 3); ## creates an array  with the @ sympbol introducing the array                              ######variable. and it initialises the array from a list. 1, 2, 3 is a list of integer      values. That's being used to initialise the array named @array
my @array = (1, 2, 3)   
say foreach @array;

Individual element of array can be specified with a subscript. 
print $array[0];  prints individual value of array
print $array[2];

---------------------------------------------------------------
_________________SLICES:_______________________________________

my @array = qw( one two three four five six seven eight nine ten );
say foreach @array;

print $array[3] will return one value

print @array[1,2,3]; will return list of values.  or individual values

to specify range of indices. 

print @array[1..5] output will be list values from 1 to 6 

because slice returns a list  we can initialise another array with it.
    for ex:

indexes:          0   1    2    3    4    5    6    7     8    9
my @array = qw ( one two three four five six seven eight nine ten);
my $a2 = @array[5,7,2,9];
say foreach @a2; 
output will be: 

six 
eight 
three 
ten

----------------------------------------------------------
___________________________HASH___________________________

hashes special kind of arrays that associates keys and values
                                  
my %hash = ( one => 'uno', two => 'dos', three => 'tres', four => 'quatro', five => 'cinco' );
                                               
while( my ($k, $v) = each %hash ) {
    say "$k -> $v";
}

-------------------------------------------------------
_____________________SUBROUTINE/FUCNTION______________


#                         \/                            
#                         || 
#                         || 
#do not put a fucking semi\/ colon here or shit goes haywire !

sub sum_of_fred_and_barney                                              #expression containing the invocation "&"
{ 
    print "Hey, you called the sum_of_fred_and_barney subroutine!\n";   
    $fred + $barney; #That's the return value #with addition of "print" $fred + $barney not return value
    # print "Hey, I'm returing a value from!\n";    #oops #Not the addition anymore; it's now the print statement
                                                    #whose return value is normally 1, meaning "printing was succesful" 
                                                    #not the return value requested, be carefull adding additional code 
                                                    #to a subroutine, since the last expression evaluated will be the return value
                                                    #a failure would result in return value of 0 or (false?)    
}

$fred = 3;
$barney = 4;
$wilma = &sum_of_fred_and_barney;        # wilma gets 7 because we asked for wilma to become the sum of fred = 3 and barney = 4 wich is 7
                                         #&sum_of_fred_and_barney calculates the value of the expression containing the invocation. 
print "\$wilma is $wilma.\n"; 

$betty = 3 * &sum_of_fred_and_barney;      # betty gets 21 because we asked for betty to become the sum of fred = 3 and barney = 4 which is 7 times 3...
                                           # ...wich is 21
                                           # betty does everything times 3 because $betty = 3 * x?  
print "\$betty is $betty.\n"; 

$dino = 5 * &sum_of_fred_and_barney;
print "\$dino is $dino.\n";
                                            #warning void context is just a fancy way of saying that you aren't using the answer,
                                            #whether that means storing it in a variable or using it any other way.


hello();

sub hello 
{
    say "This is the hello function.';
}

#Lexical Scoping
#my variable inside the fucntion, "my" keyword creates variable with local scope.
#$x inside function is used inside function block 
#local variables will allways take precedent over outside variables

#return values can return 0's or more scalar values as a list
#

#Returning values #return #subroutines #functions

# print func();

# sub func
# {
#     return 'This is a wonderful function.';
# }

# --------------Using return to get list values-----------------

# print foreach func(). "\n";

# sub func
# {
#     return ( 1, 2, 3, 4, 5 );
# }

# -------------Printing with eacht list element on new line------------------

# print qq($_\n) foreach func();
# sub func
# {
#     return ( 1, 2, 3, 4, 5 );
# }


# -------------------- Static Variables -----------

# func();
# func();
# func();
# func();
# func();
# func();

# sub func
# {
    
#    my $n = 10; #n w. 10 
#    print ++$n; #increment $n 10 w. 11 en print
# }

# Static variable Example: 

# func();
# func();
# func();
# func();
# func();
# func();

# sub func
# {
    
#    state $n = 10; #state counts with increment of 1 gebruikt "use feature 'state'; bovenaan
#    print ++$n; #increment $n + 1 x aantal "func ();" = 11 12 13 14 15 
# }

# --------- Predeclared Functions ---------
#func (); gebruiken op functie te invoken werkt niet met "func;" -> geeft error
#om functie te gebruiken zoals de predeclared -> use subs qw ( "chooseurself"* ); 
#Meer om het gebruiksgemak van functies te verhogen. En ze gemakkelijker aan te roepen.

use subs qw( func );

func 'Foo', 'bar', 'baz';

sub func
{
   print foreach @_ ;
}
